import { createSuccessResponse, createErrorResponse, API_CODES } from '~~/server/utils/response'
import { getRequiredCurrentUser } from '~~/server/utils/auth'
import { availabilityCacheService } from '~~/server/services/availability-cache'

interface AvailabilityRequest {
  roomIds: string[]
  startTime: string // ISO datetime
  endTime: string   // ISO datetime
  includeUnavailable?: boolean
}

interface AvailabilityCacheKey {
  roomIds: string[]
  startTime: string
  endTime: string
}

interface AvailabilityResponse {
  [roomId: string]: {
    roomId: string
    roomName: string
    status: 'available' | 'unavailable' | 'maintenance'
    availableSlots?: Array<{
      startTime: string
      endTime: string
      duration: number // minutes
    }>
    reservations?: Array<{
      id: string
      title: string
      startTime: string
      endTime: string
      organizerName?: string
      status: string
    }>
    maintenanceSlots?: Array<{
      id: string
      startTime: string
      endTime: string
      reason?: string
    }>
  }
}

export default defineEventHandler(async (event) => {
  const startTimeOverall = Date.now()

  try {
    // éªŒè¯ç”¨æˆ·ä¼šè¯
    const user = await getRequiredCurrentUser(event)

    // è·å–è¯·æ±‚ä½“
    const body = await readBody(event) as AvailabilityRequest

    // éªŒè¯è¯·æ±‚å‚æ•°
    if (!body.roomIds || !Array.isArray(body.roomIds) || body.roomIds.length === 0) {
      return createErrorResponse(API_CODES.INVALID_REQUEST, 'roomIds å‚æ•°æ˜¯å¿…éœ€çš„')
    }

    if (!body.startTime || !body.endTime) {
      return createErrorResponse(API_CODES.INVALID_REQUEST, 'startTime å’Œ endTime å‚æ•°æ˜¯å¿…éœ€çš„')
    }

    const startTime = new Date(body.startTime)
    const endTime = new Date(body.endTime)

    if (isNaN(startTime.getTime()) || isNaN(endTime.getTime())) {
      return createErrorResponse(API_CODES.INVALID_REQUEST, 'æ—¶é—´æ ¼å¼æ— æ•ˆ')
    }

    if (startTime >= endTime) {
      return createErrorResponse(API_CODES.INVALID_REQUEST, 'å¼€å§‹æ—¶é—´å¿…é¡»æ—©äºç»“æŸæ—¶é—´')
    }

    // æŸ¥è¯¢æ—¶é—´èŒƒå›´é™åˆ¶ï¼ˆæœ€å¤šæŸ¥è¯¢30å¤©ï¼‰
    const maxQueryRange = 30 * 24 * 60 * 60 * 1000 // 30å¤©
    if (endTime.getTime() - startTime.getTime() > maxQueryRange) {
      return createErrorResponse(API_CODES.INVALID_REQUEST, 'æŸ¥è¯¢æ—¶é—´èŒƒå›´ä¸èƒ½è¶…è¿‡30å¤©')
    }

    // æ£€æŸ¥ç¼“å­˜
    const cacheParams: AvailabilityCacheKey = {
      roomIds: body.roomIds,
      startTime: body.startTime,
      endTime: body.endTime
    }

    // å°è¯•ä»ç¼“å­˜è·å–æ•°æ®
    const cachedData = await availabilityCacheService.getAvailability(cacheParams)
    if (cachedData) {
      const cacheTime = Date.now() - startTimeOverall
      console.log(`ğŸ“¦ Cache hit! Total response time: ${cacheTime}ms`)
      return createSuccessResponse(cachedData)
    }

    // è·å–åˆ†å¸ƒå¼é”é˜²æ­¢ç¼“å­˜å‡»ç©¿
    const lockValue = await availabilityCacheService.getCacheLock(cacheParams, 10000)
    let needsToSetCache = false

    try {
      // å†æ¬¡æ£€æŸ¥ç¼“å­˜ï¼ˆé˜²æ­¢é”ç«äº‰æœŸé—´å…¶ä»–è¯·æ±‚å·²ç»è®¾ç½®äº†ç¼“å­˜ï¼‰
      const recheckedData = await availabilityCacheService.getAvailability(cacheParams)
      if (recheckedData) {
        const cacheTime = Date.now() - startTimeOverall
        console.log(`ğŸ“¦ Cache hit after lock! Total response time: ${cacheTime}ms`)
        return createSuccessResponse(recheckedData)
      }

      needsToSetCache = true

      // è·å–ä¼šè®®å®¤ä¿¡æ¯
      const rooms = await prisma.meetingRoom.findMany({
        where: {
          id: { in: body.roomIds },
          status: 'AVAILABLE'
        },
        select: {
          id: true,
          name: true,
          capacity: true,
          status: true,
          equipment: true
        }
      })

      if (rooms.length === 0) {
        return createErrorResponse(API_CODES.NOT_FOUND, 'æœªæ‰¾åˆ°å¯ç”¨çš„ä¼šè®®å®¤')
      }

      // æŸ¥è¯¢é¢„çº¦æ•°æ®
      const reservations = await prisma.reservation.findMany({
        where: {
          roomId: { in: body.roomIds },
          OR: [
            {
              AND: [
                { startTime: { gte: startTime } },
                { startTime: { lte: endTime } }
              ]
            },
            {
              AND: [
                { endTime: { gte: startTime } },
                { endTime: { lte: endTime } }
              ]
            },
            {
              AND: [
                { startTime: { lte: startTime } },
                { endTime: { gte: endTime } }
              ]
            }
          ],
          status: { in: ['PENDING', 'CONFIRMED', 'IN_PROGRESS'] }
        },
        select: {
          id: true,
          title: true,
          startTime: true,
          endTime: true,
          roomId: true,
          userId: true,
          status: true
        },
        orderBy: {
          startTime: 'asc'
        }
      })

      // è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆç”¨äºæ˜¾ç¤ºç»„ç»‡è€…ï¼‰
      const userIds = [...new Set(reservations.map(r => r.userId))]
      const users = userIds.length > 0 ? await prisma.user.findMany({
        where: { id: { in: userIds } },
        select: { id: true, name: true }
      }) : []

      const userMap = new Map(users.map(u => [u.id, u.name]))

      // æ„å»ºå“åº”æ•°æ®
      const response: AvailabilityResponse = {}

      // åˆå§‹åŒ–æ‰€æœ‰ä¼šè®®å®¤çš„æ•°æ®ç»“æ„
      rooms.forEach(room => {
        response[room.id] = {
          roomId: room.id,
          roomName: room.name,
          status: 'available',
          availableSlots: [],
          reservations: [],
          maintenanceSlots: []
        }
      })

      // å¤„ç†é¢„çº¦æ•°æ®
      reservations.forEach(reservation => {
        if (response[reservation.roomId]) {
          response[reservation.roomId].reservations?.push({
            id: reservation.id,
            title: reservation.title,
            startTime: reservation.startTime.toISOString(),
            endTime: reservation.endTime.toISOString(),
            organizerName: userMap.get(reservation.userId) || 'æœªçŸ¥ç”¨æˆ·',
            status: reservation.status
          })

          // æ›´æ–°çŠ¶æ€
          if (response[reservation.roomId].status === 'available') {
            response[reservation.roomId].status = 'unavailable'
          }
        }
      })

      // æ¨¡æ‹Ÿç»´æŠ¤æ—¶é—´æ®µï¼ˆå®é™…é¡¹ç›®ä¸­åº”è¯¥ä»æ•°æ®åº“æˆ–é…ç½®ä¸­è·å–ï¼‰
      const generateMaintenanceSlots = (roomId: string) => {
        const slots = []
        const currentDate = new Date()

        // æ¯å‘¨æ—¥å‡Œæ™¨ 2:00-6:00 ä¸ºç»´æŠ¤æ—¶é—´
        for (let i = 0; i < 4; i++) {
          const sunday = new Date(currentDate)
          sunday.setDate(sunday.getDate() + (7 - sunday.getDay() + i * 7))
          sunday.setHours(2, 0, 0, 0)

          const endSunday = new Date(sunday)
          endSunday.setHours(6, 0, 0, 0)

          // æ£€æŸ¥æ˜¯å¦åœ¨æŸ¥è¯¢èŒƒå›´å†…
          if ((sunday >= startTime && sunday <= endTime) ||
              (endSunday >= startTime && endSunday <= endTime) ||
              (sunday <= startTime && endSunday >= endTime)) {
            slots.push({
              id: `maintenance-${roomId}-${i}`,
              startTime: sunday.toISOString(),
              endTime: endSunday.toISOString(),
              reason: 'å®šæœŸç»´æŠ¤'
            })
          }
        }

        return slots
      }

      // ä¸ºæ¯ä¸ªä¼šè®®å®¤æ·»åŠ ç»´æŠ¤æ—¶é—´æ®µ
      rooms.forEach(room => {
        const maintenanceSlots = generateMaintenanceSlots(room.id)
        response[room.id].maintenanceSlots = maintenanceSlots

        // å¦‚æœæœ‰ç»´æŠ¤æ—¶é—´æ®µï¼Œæ›´æ–°çŠ¶æ€
        if (maintenanceSlots.length > 0) {
          const hasActiveMaintenance = maintenanceSlots.some(slot => {
            const slotStart = new Date(slot.startTime)
            const slotEnd = new Date(slot.endTime)
            const now = new Date()
            return (slotStart <= now && slotEnd >= now)
          })

          if (hasActiveMaintenance) {
            response[room.id].status = 'maintenance'
          }
        }
      })

      // ç”Ÿæˆå¯ç”¨æ—¶é—´æ®µ
      rooms.forEach(room => {
        const roomData = response[room.id]
        const unavailableSlots = [
          ...(roomData.reservations || []).map(r => ({
            start: new Date(r.startTime),
            end: new Date(r.endTime)
          })),
          ...(roomData.maintenanceSlots || []).map(m => ({
            start: new Date(m.startTime),
            end: new Date(m.endTime)
          }))
        ]

        // æŒ‰å¼€å§‹æ—¶é—´æ’åº
        unavailableSlots.sort((a, b) => a.start.getTime() - b.start.getTime())

        // ç”Ÿæˆå¯ç”¨æ—¶é—´æ®µ
        const availableSlots = []
        let currentTime = new Date(Math.max(startTime, new Date()))

        // åªç”Ÿæˆæœªæ¥çš„å¯ç”¨æ—¶é—´æ®µ
        if (currentTime > endTime) {
          roomData.availableSlots = []
          return
        }

        // åˆå¹¶é‡å çš„ä¸å¯ç”¨æ—¶é—´æ®µ
        const mergedUnavailableSlots = []
        for (const slot of unavailableSlots) {
          if (mergedUnavailableSlots.length === 0) {
            mergedUnavailableSlots.push({ ...slot })
          } else {
            const lastSlot = mergedUnavailableSlots[mergedUnavailableSlots.length - 1]
            if (slot.start <= lastSlot.end) {
              // åˆå¹¶é‡å æ—¶é—´æ®µ
              lastSlot.end = new Date(Math.max(lastSlot.end.getTime(), slot.end.getTime()))
            } else {
              mergedUnavailableSlots.push({ ...slot })
            }
          }
        }

        // ç”Ÿæˆå¯ç”¨æ—¶é—´æ®µ
        for (const unavailableSlot of mergedUnavailableSlots) {
          if (currentTime < unavailableSlot.start) {
            const duration = (unavailableSlot.start.getTime() - currentTime.getTime()) / (1000 * 60)
            if (duration >= 30) { // æœ€çŸ­30åˆ†é’Ÿçš„å¯ç”¨æ—¶é—´æ®µ
              availableSlots.push({
                startTime: currentTime.toISOString(),
                endTime: unavailableSlot.start.toISOString(),
                duration: Math.round(duration)
              })
            }
          }
          currentTime = new Date(Math.max(currentTime.getTime(), unavailableSlot.end.getTime()))
        }

        // æ·»åŠ æœ€åä¸€ä¸ªå¯ç”¨æ—¶é—´æ®µ
        if (currentTime < endTime) {
          const duration = (endTime.getTime() - currentTime.getTime()) / (1000 * 60)
          if (duration >= 30) {
            availableSlots.push({
              startTime: currentTime.toISOString(),
              endTime: endTime.toISOString(),
              duration: Math.round(duration)
            })
          }
        }

        roomData.availableSlots = availableSlots
      })

      // ç¼“å­˜ç»“æœ
      if (needsToSetCache) {
        await availabilityCacheService.setAvailability(cacheParams, response, 300) // 5åˆ†é’ŸTTL
      }

    } finally {
      // é‡Šæ”¾åˆ†å¸ƒå¼é”
      if (lockValue) {
        await availabilityCacheService.releaseCacheLock(cacheParams, lockValue)
      }
    }

    // è®°å½•æ€§èƒ½æŒ‡æ ‡
    const totalTime = Date.now() - startTimeOverall
    console.log(`ğŸš€ Availability query completed in ${totalTime}ms for ${body.roomIds.length} rooms`)

    // æ€§èƒ½è­¦å‘Š
    if (totalTime > 200) {
      console.warn(`âš ï¸ Slow availability query: ${totalTime}ms (target: < 200ms)`)
    }

    return createSuccessResponse(response)

  } catch (error) {
    console.error('âŒ Availability query error:', error)

    // é‡Šæ”¾é”ï¼ˆå¦‚æœæœ‰ï¼‰
    try {
      const cacheParams: AvailabilityCacheKey = {
        roomIds: body?.roomIds || [],
        startTime: body?.startTime || '',
        endTime: body?.endTime || ''
      }
      const lockValue = await availabilityCacheService.getCacheLock(cacheParams, 10000)
      if (lockValue) {
        await availabilityCacheService.releaseCacheLock(cacheParams, lockValue)
      }
    } catch (lockError) {
      console.warn('Failed to release cache lock on error:', lockError)
    }

    if (error instanceof Error) {
      return createErrorResponse(API_CODES.INTERNAL_SERVER_ERROR, error.message)
    }

    return createErrorResponse(API_CODES.INTERNAL_SERVER_ERROR, 'æŸ¥è¯¢å¯ç”¨æ€§å¤±è´¥')
  }
})