# meeting-manage - Architecture Decision Document

**Author:** bmad
**Date:** 2025-11-15
**Version:** 1.0
**Generated by:** BMAD Decision Architecture Workflow

---

## Executive Summary

智能会议室管理系统是一个基于 Nuxt 4 全栈架构的企业级解决方案，采用现代化的技术栈和设计模式，为企业提供高效、智能的会议室资源配置和管理平台。

该架构采用 **sfxcode/nuxt-primevue-starter** 作为基础模板，结合 MySQL 数据库、Redis 缓存、Prisma ORM 和 PrimeVue UI 组件库，实现了一个完整的企业级应用架构。

### 项目初始化

**首选初始化命令：**
```bash
# 克隆启动模板
git clone https://github.com/sfxcode/nuxt-primevue-starter.git meeting-manage

# 进入项目目录
cd meeting-manage

# 安装依赖
pnpm install

# 配置环境变量
cp .env.example .env.local

# 配置数据库连接
# DATABASE_URL="mysql://root:407033@localhost:3307/meeting_manage"

# 生成 Prisma 客户端
pnpm db:generate

# 创建数据库迁移
pnpm db:migrate

# 启动开发服务器
pnpm dev
```

**模板提供的架构决策：**
- ✅ Nuxt 4 + TypeScript 严格模式
- ✅ PrimeVue Styled Mode + Aura 主题
- ✅ FormKit 企业级表单验证
- ✅ Pinia 状态管理
- ✅ ESLint + Prettier 代码质量工具

---

## Decision Summary

| Category | Decision | Version | Affects Epics | Rationale |
| -------- | -------- | ------- | ------------- | --------- |
| **Framework** | Nuxt 4 Full-Stack | latest | 所有史诗 | 现代化全栈架构，统一开发体验 |
| **UI Library** | PrimeVue Styled Mode | 4.x | Epic 1,2,3,4,7 | 企业级组件库，专业商务外观 |
| **Database** | MySQL + Prisma ORM | 8.0 + 5.x | 所有史诗 | 企业级数据持久化，类型安全 |
| **State Management** | Pinia | 2.x | 所有史诗 | Vue 3 专用状态管理，简洁高效 |
| **Styling** | Tailwind CSS + PrimeVue | 3.x + 4.x | Epic 2,4 | 实用优先的 CSS 框架，主题定制 |
| **Authentication** | JWT + Session Management | - | Epic 1 | 无状态认证，支持企业 SSO 扩展 |
| **File Storage** | Local File System | - | Epic 2,5 | 简单可靠的本地文件存储 |
| **Caching** | Redis | 7.x | Epic 2,3,6 | 高性能缓存，实时数据同步 |
| **API Design** | RESTful + Unified Response | - | 所有史诗 | 标准化 API，统一响应格式 |

---

## Project Structure

```
meeting-manage/
├── .env.local                    # 环境变量配置
├── .env.example                  # 环境变量示例
├── .gitignore                    # Git 忽略文件
├── README.md                     # 项目说明
├── package.json                  # 依赖管理
├── pnpm-lock.yaml               # 依赖锁定
├── nuxt.config.ts               # Nuxt 配置
├── tsconfig.json                # TypeScript 配置
├── tailwind.config.js           # Tailwind 配置
├── prisma/
│   ├── schema.prisma            # 数据模型定义
│   ├── migrations/              # 数据库迁移文件
│   └── seed.ts                  # 初始数据
├── server/
│   ├── api/
│   │   └── v1/                  # API v1 版本
│   │       ├── auth/           # 认证相关 API
│   │       ├── users/          # 用户管理 API
│   │       ├── rooms/          # 会议室管理 API
│   │       ├── reservations/   # 预约管理 API
│   │       ├── checkin/        # 签到管理 API
│   │       ├── system/         # 系统配置 API
│   │       └── upload/         # 文件上传 API
│   ├── middleware/              # 服务端中间件
│   ├── utils/                   # 服务端工具函数
│   └── types/                   # 服务端类型定义
├── composables/                 # 组合式函数
├── components/
│   ├── common/                  # 通用组件
│   ├── forms/                   # 表单组件
│   ├── layout/                  # 布局组件
│   └── features/                # 功能组件
│       ├── rooms/               # 会议室相关组件
│       ├── reservations/        # 预约相关组件
│       ├── checkin/             # 签到相关组件
│       └── admin/               # 管理后台组件
├── pages/
│   ├── index.vue                # 首页
│   ├── rooms/                   # 会议室页面
│   ├── reservations/            # 预约页面
│   ├── profile/                 # 个人中心
│   └── admin/                   # 管理后台
├── layouts/
│   ├── default.vue              # 默认布局
│   ├── auth.vue                 # 认证页面布局
│   └── admin.vue                # 管理后台布局
├── stores/                      # Pinia 状态管理
│   ├── auth.ts                  # 认证状态
│   ├── rooms.ts                 # 会议室状态
│   ├── reservations.ts          # 预约状态
│   └── system.ts                # 系统状态
├── types/                       # 类型定义
│   ├── api.ts                   # API 类型
│   ├── models.ts                # 数据模型类型
│   └── components.ts            # 组件类型
├── utils/                       # 工具函数
│   ├── api.ts                   # API 工具
│   ├── auth.ts                  # 认证工具
│   ├── date.ts                  # 日期工具
│   └── validation.ts            # 验证工具
├── plugins/                     # Nuxt 插件
│   ├── api.ts                   # API 插件
│   ├── auth.ts                  # 认证插件
│   └── primevue.ts              # PrimeVue 插件
├── middleware/                  # 前端中间件
│   ├── auth.ts                  # 认证中间件
│   ├── admin.ts                 # 管理员中间件
│   └── guest.ts                 # 访客中间件
├── assets/                      # 静态资源
│   ├── css/                     # 样式文件
│   ├── images/                  # 图片资源
│   └── icons/                   # 图标资源
├── public/                      # 公共文件
│   ├── favicon.ico              # 网站图标
│   └── uploads/                 # 上传文件存储
│       ├── rooms/               # 会议室图片
│       ├── users/               # 用户头像
│       └── reservations/        # 预约附件
└── docs/                        # 项目文档
    ├── architecture.md          # 架构文档
    ├── api.md                   # API 文档
    └── deployment.md            # 部署文档
```

---

## Epic to Architecture Mapping

| Epic | Architecture Components | Implementation Location |
| ---- | ----------------------- | --------------------- |
| **Epic 1: 基础设施与用户认证** | JWT 认证、RBAC 权限、审计日志 | `stores/auth.ts`, `server/api/v1/auth/`, `server/middleware/` |
| **Epic 2: 会议室核心管理** | 会议室数据模型、文件上传、搜索筛选 | `components/features/rooms/`, `server/api/v1/rooms/`, `utils/fileUpload.ts` |
| **Epic 3: 预约系统核心** | 预约数据模型、冲突检测、状态管理 | `components/features/reservations/`, `stores/reservations.ts`, `server/api/v1/reservations/` |
| **Epic 4: 签到与验证系统** | 签到数据模型、二维码生成、验证逻辑 | `components/features/checkin/`, `server/api/v1/checkin/` |
| **Epic 5: 智能设备集成** | 设备抽象层、协议适配（后期扩展） | `server/services/iot/`, `components/features/devices/` |
| **Epic 6: 数据分析洞察** | 统计查询、数据可视化、报表生成 | `components/analytics/`, `server/api/v1/analytics/` |
| **Epic 7: 系统配置与管理** | 配置管理、通知系统、品牌定制 | `stores/system.ts`, `server/api/v1/system/`, `plugins/` |

---

## Technology Stack Details

### Core Technologies

**前端技术栈：**
- **Nuxt 4** - Vue.js 全栈框架，支持 SSR/SSG/SPA
- **Vue 3** - 渐进式 JavaScript 框架，组合式 API
- **TypeScript** - 类型安全的 JavaScript 超集
- **PrimeVue 4.x** - 企业级 Vue UI 组件库
- **Tailwind CSS 3.x** - 实用优先的 CSS 框架
- **Pinia 2.x** - Vue 3 状态管理库

**后端技术栈：**
- **Nuxt Server** - 内置 Nitro 服务器
- **MySQL 8.0** - 关系型数据库
- **Prisma 5.x** - 现代化数据库 ORM
- **Redis 7.x** - 内存数据结构存储
- **JWT** - JSON Web Token 认证

**开发工具：**
- **Vite** - 快速的前端构建工具
- **ESLint** - JavaScript 代码检查工具
- **Prettier** - 代码格式化工具
- **pnpm** - 快速、节省磁盘空间的包管理器

### Integration Points

**数据库集成：**
```typescript
// Prisma 配置
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// 连接字符串
mysql://root:407033@localhost:3307/meeting_manage
```

**缓存集成：**
```typescript
// Redis 缓存配置
import Redis from 'ioredis'

const redis = new Redis({
  host: 'localhost',
  port: 6379,
  db: 0
})
```

**认证集成：**
```typescript
// JWT 认证中间件
export default defineNuxtRouteMiddleware((to) => {
  const authStore = useAuthStore()
  if (!authStore.isAuthenticated && to.path !== '/auth/login') {
    return navigateTo('/auth/login')
  }
})
```

---

## Implementation Patterns

### 1. API 响应格式模式

**统一响应接口：**
```typescript
interface ApiResponse<T = any> {
  success: boolean
  data?: T | T[]
  code: string
  message: string
  meta?: {
    pagination?: {
      page: number
      limit: number
      total: number
    }
    timestamp: string
    traceId?: string
  }
}
```

**状态码规范：**
- 成功：20000-29999
- 业务错误：40000-49999
- 系统错误：50000-59999

### 2. 错误处理模式

**服务端错误处理：**
```typescript
export default defineEventHandler(async (event) => {
  try {
    const data = await someOperation()
    return createSuccessResponse(data)
  }
  catch (error) {
    throw createError({
      statusCode: 500,
      statusMessage: error.message
    })
  }
})
```

**前端错误处理：**
```typescript
const { error, pending } = await useFetch('/api/v1/rooms')
if (error.value) {
  const systemStore = useSystemStore()
  systemStore.addNotification({
    type: 'error',
    title: '加载失败',
    message: error.value.message
  })
}
```

### 3. 数据验证模式

**Prisma 模式验证：**
```prisma
model MeetingRoom {
  name        String   @db.VarChar(100)
  capacity    Int      @db.TinyInt
  location    String   @db.VarChar(200)
  status      RoomStatus @default(AVAILABLE)
}
```

**前端表单验证：**
```vue
<template>
  <FormKit
    type="form"
    :value="formData"
    @submit="handleSubmit"
  >
    <FormKit
      type="text"
      name="name"
      label="会议室名称"
      validation="required|length:3,100"
    />
  </FormKit>
</template>
```

### 4. 状态管理模式

**组合式 Store：**
```typescript
export const useRoomsStore = defineStore('rooms', {
  state: () => ({
    rooms: [],
    loading: false,
    error: null
  }),

  actions: {
    async fetchRooms() {
      this.loading = true
      try {
        const response = await $fetch('/api/v1/rooms')
        this.rooms = response.data
      }
      catch (error) {
        this.error = error.message
      }
      finally {
        this.loading = false
      }
    }
  }
})
```

### 5. 缓存策略模式

**多层缓存架构：**
```typescript
// 1. 内存缓存（客户端）
const cache = useNuxtApp().$cache

// 2. Redis 缓存（服务端）
await cacheService.set('room:list', rooms, { ttl: 600 })

// 3. 数据库查询缓存
const rooms = await prisma.meetingRoom.findMany({
  cacheStrategy: { ttl: 60 }
})
```

---

## Consistency Rules

### Naming Conventions

**文件命名：**
- 组件文件：`PascalCase.vue` (例：`RoomCard.vue`)
- 页面文件：`kebab-case.vue` (例：`room-detail.vue`)
- 工具文件：`camelCase.ts` (例：`fileUpload.ts`)
- API 文件：`kebab-case.post.ts` (例：`create-room.post.ts`)

**变量命名：**
- 变量：`camelCase` (例：`roomList`)
- 常量：`UPPER_SNAKE_CASE` (例：`API_BASE_URL`)
- 函数：`camelCase` (例：`fetchRooms`)
- 类名：`PascalCase` (例：`RoomService`)

**数据库命名：**
- 表名：`snake_case` (例：`meeting_rooms`)
- 字段名：`snake_case` (例：`created_at`)
- 索引名：`idx_table_column` (例：`idx_rooms_status`)

### Code Organization

**组件结构：**
```vue
<script setup lang="ts">
import type { Room } from '~/types/models'
// 导入
import { computed, ref } from 'vue'

// Props 定义
interface Props {
  room: Room
  showActions?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  showActions: true
})

// Emits 定义
const emit = defineEmits<{
  select: [room: Room]
  update: [room: Room]
}>()

// 响应式数据
const loading = ref(false)

// 计算属性
const isAvailable = computed(() => props.room.status === 'AVAILABLE')

// 方法
function handleSelect() {
  emit('select', props.room)
}

// 生命周期
onMounted(() => {
  // 初始化逻辑
})
</script>

<template>
  <!-- 模板内容 -->
</template>

<style scoped>
/* 样式 */
</style>
```

**API 结构：**
```typescript
// server/api/v1/rooms/index.get.ts
export default defineEventHandler(async (event) => {
  try {
    // 参数验证
    const query = getQuery(event)

    // 业务逻辑
    const rooms = await roomService.getRooms(query)

    // 缓存处理
    await cacheService.set('room:list', rooms, { ttl: 600 })

    // 响应
    return createSuccessResponse(rooms)
  }
  catch (error) {
    throw createError({
      statusCode: 500,
      statusMessage: error.message
    })
  }
})
```

### Error Handling

**服务端错误处理：**
```typescript
// 统一错误处理中间件
export default defineEventHandler(async (event) => {
  try {
    return await handler(event)
  }
  catch (error) {
    console.error('API Error:', error)

    // 记录错误日志
    await logError(error, event)

    // 返回统一错误响应
    return createErrorResponse(
      getErrorCode(error),
      getErrorMessage(error)
    )
  }
})
```

**前端错误处理：**
```typescript
// 全局错误处理
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.hook('vue:error', (error, instance, info) => {
    console.error('Vue Error:', error, info)

    // 发送错误报告
    reportError(error, info)

    // 显示用户友好的错误信息
    const systemStore = useSystemStore()
    systemStore.addNotification({
      type: 'error',
      title: '系统错误',
      message: '发生了意外错误，请刷新页面重试'
    })
  })
})
```

### Logging Strategy

**结构化日志：**
```typescript
interface LogEntry {
  timestamp: string
  level: 'debug' | 'info' | 'warn' | 'error'
  message: string
  context?: Record<string, any>
  userId?: string
  traceId?: string
}

export class Logger {
  static info(message: string, context?: Record<string, any>) {
    this.log('info', message, context)
  }

  static error(message: string, error?: Error, context?: Record<string, any>) {
    this.log('error', message, { ...context, error: error?.stack })
  }

  private static log(level: string, message: string, context?: Record<string, any>) {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: level as any,
      message,
      context
    }

    console.log(JSON.stringify(entry, null, 2))

    // 发送到日志服务
    this.sendToLogService(entry)
  }
}
```

---

## Data Architecture

### Core Data Models

```prisma
// 用户管理
model User {
  id          String   @id @default(cuid())
  email       String   @unique
  name        String
  department  String?
  role        UserRole @default(USER)
  avatar      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  reservations Reservation[]
  auditLogs    AuditLog[]

  @@map("users")
}

enum UserRole {
  ADMIN
  MANAGER
  USER
}

// 会议室管理
model MeetingRoom {
  id            String  @id @default(cuid())
  name          String
  location      String
  capacity      Int
  description   String?
  equipment     Json?
  images        Json?
  status        RoomStatus @default(AVAILABLE)
  rules         Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  reservations Reservation[]

  @@map("meeting_rooms")
}

enum RoomStatus {
  AVAILABLE
  OCCUPIED
  MAINTENANCE
  DISABLED
}

// 预约管理
model Reservation {
  id           String           @id @default(cuid())
  title        String
  description  String?
  startTime    DateTime
  endTime      DateTime
  status       ReservationStatus @default(PENDING)
  meetingType  String?
  attendeeCount Int?
  equipment    Json?
  services     Json?
  notes        String?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  userId       String
  user         User             @relation(fields: [userId], references: [id])
  roomId       String
  room         MeetingRoom      @relation(fields: [roomId], references: [id])

  checkIns     CheckIn[]

  @@map("reservations")
}

enum ReservationStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// 签到管理
model CheckIn {
  id           String    @id @default(cuid())
  method       CheckInMethod
  checkInTime  DateTime  @default(now())
  checkOutTime DateTime?
  deviceInfo   Json?
  location     Json?
  notes        String?

  reservationId String
  reservation   Reservation @relation(fields: [reservationId], references: [id])

  @@map("check_ins")
}

enum CheckInMethod {
  QR_CODE
  FACE_RECOGNITION
  MANUAL
}

// 系统配置
model SystemConfig {
  id          String   @id @default(cuid())
  key         String   @unique
  value       Json
  description String?
  category    String
  updatedAt   DateTime @updatedAt

  @@map("system_config")
}

// 审计日志
model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  action    String
  resource  String
  resourceId String?
  details   Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  user      User?    @relation(fields: [userId], references: [id])

  @@map("audit_logs")
}
```

### Data Relationships

**主要关系图：**
- User 1:N Reservation (一个用户可以有多个预约)
- MeetingRoom 1:N Reservation (一个会议室可以有多个预约)
- Reservation 1:N CheckIn (一个预约可以有多个签到记录)
- User 1:N AuditLog (一个用户可以有多条审计日志)

**数据一致性策略：**
- 使用 Prisma 事务确保数据一致性
- 实现乐观锁防止并发冲突
- 定期数据备份和恢复策略

---

## API Contracts

### Authentication APIs

```typescript
// POST /api/v1/auth/login
interface LoginRequest {
  email: string
  password: string
}

interface LoginResponse {
  user: User
  token: string
  refreshToken: string
  permissions: string[]
}

// GET /api/v1/auth/me
interface AuthMeResponse {
  user: User
  permissions: string[]
}
```

### Room Management APIs

```typescript
// GET /api/v1/rooms
interface GetRoomsQuery {
  page?: number
  limit?: number
  search?: string
  capacity?: number
  location?: string
  status?: RoomStatus
}

interface GetRoomsResponse {
  rooms: MeetingRoom[]
  pagination: {
    page: number
    limit: number
    total: number
  }
}

// POST /api/v1/rooms
interface CreateRoomRequest {
  name: string
  location: string
  capacity: number
  description?: string
  equipment?: Record<string, any>
  rules?: Record<string, any>
}
```

### Reservation APIs

```typescript
// POST /api/v1/reservations
interface CreateReservationRequest {
  title: string
  roomId: string
  startTime: string // ISO datetime
  endTime: string // ISO datetime
  description?: string
  attendeeCount?: number
  equipment?: Record<string, any>
}

// GET /api/v1/reservations/availability
interface AvailabilityQuery {
  roomId: string
  startTime: string
  endTime: string
}

interface AvailabilityResponse {
  available: boolean
  conflicts?: Reservation[]
  suggestions?: TimeSlot[]
}
```

### Check-in APIs

```typescript
// POST /api/v1/checkin/qr/:code
interface QRCheckInRequest {
  code: string // 二维码内容
}

interface CheckInResponse {
  reservation: Reservation
  checkInRecord: CheckIn
  roomInfo: MeetingRoom
}
```

### Response Format Standards

```typescript
// 成功响应
{
  "success": true,
  "data": { ... },
  "code": "20000",
  "message": "操作成功",
  "meta": {
    "timestamp": "2025-11-15T10:30:00Z",
    "traceId": "trace_123456"
  }
}

// 错误响应
{
  "success": false,
  "code": "41002",
  "message": "该时间段会议室已被预约",
  "meta": {
    "timestamp": "2025-11-15T10:30:00Z",
    "traceId": "trace_123457"
  }
}
```

---

## Security Architecture

### Authentication & Authorization

**JWT Token 管理：**
```typescript
interface JWTPayload {
  sub: string // 用户ID
  email: string // 用户邮箱
  role: UserRole // 用户角色
  permissions: string[]
  iat: number // 签发时间
  exp: number // 过期时间
}

// Token 生成
const token = jwt.sign(payload, process.env.JWT_SECRET, {
  expiresIn: '1h'
})

// Token 验证中间件
export default defineEventHandler(async (event) => {
  const token = getCookie(event, 'auth_token')

  if (!token) {
    throw createError({
      statusCode: 401,
      statusMessage: '未授权访问'
    })
  }

  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET) as JWTPayload
    event.context.user = payload
  }
  catch (error) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Token 无效'
    })
  }
})
```

**RBAC 权限控制：**
```typescript
// 权限检查中间件
export default defineEventHandler(async (event) => {
  const user = event.context.user
  const requiredPermission = 'rooms:create'

  if (!user.permissions.includes(requiredPermission) && !hasRole(user, 'ADMIN')) {
    throw createError({
      statusCode: 403,
      statusMessage: '权限不足'
    })
  }
})

// 权限检查工具
export function hasPermission(user: JWTPayload, permission: string): boolean {
  return user.permissions.includes(permission)
}

export function hasRole(user: JWTPayload, role: UserRole): boolean {
  return user.role === role || (role === 'MANAGER' && user.role === 'ADMIN')
}
```

### Data Security

**数据加密：**
```typescript
// 敏感数据加密
import crypto from 'node:crypto'

const algorithm = 'aes-256-gcm'
const secretKey = process.env.ENCRYPTION_KEY!

export function encrypt(text: string): string {
  const iv = crypto.randomBytes(16)
  const cipher = crypto.createCipher(algorithm, secretKey, iv)

  let encrypted = cipher.update(text, 'utf8', 'hex')
  encrypted += cipher.final('hex')

  const tag = cipher.getAuthTag()

  return `${iv.toString('hex')}:${tag.toString('hex')}:${encrypted}`
}

export function decrypt(encryptedData: string): string {
  const parts = encryptedData.split(':')
  const iv = Buffer.from(parts[0], 'hex')
  const tag = Buffer.from(parts[1], 'hex')
  const encrypted = parts[2]

  const decipher = crypto.createDecipher(algorithm, secretKey, iv)
  decipher.setAuthTag(tag)

  let decrypted = decipher.update(encrypted, 'hex', 'utf8')
  decrypted += decipher.final('utf8')

  return decrypted
}
```

**输入验证：**
```typescript
// Zod 验证模式
import { z } from 'zod'

const CreateRoomSchema = z.object({
  name: z.string().min(3).max(100),
  location: z.string().min(1).max(200),
  capacity: z.number().min(1).max(1000),
  description: z.string().max(1000).optional(),
  equipment: z.record(z.any()).optional()
})

// API 验证中间件
export default defineEventHandler(async (event) => {
  const body = await readBody(event)

  try {
    const validatedData = CreateRoomSchema.parse(body)
    event.context.validatedData = validatedData
  }
  catch (error) {
    throw createError({
      statusCode: 400,
      statusMessage: '数据验证失败',
      data: error.errors
    })
  }
})
```

### API Security

**请求频率限制：**
```typescript
// Redis 限流实现
export async function rateLimit(
  identifier: string,
  limit: number,
  windowMs: number
): Promise<{ allowed: boolean, remaining: number }> {
  const key = `rate_limit:${identifier}`
  const window = Math.floor(Date.now() / windowMs)
  const windowKey = `${key}:${window}`

  const current = await cacheService.increment(windowKey)

  // 设置过期时间
  await cacheService.expire(windowKey, Math.ceil(windowMs / 1000))

  return {
    allowed: current <= limit,
    remaining: Math.max(0, limit - current)
  }
}

// 限流中间件
export default defineEventHandler(async (event) => {
  const clientIP = getClientIP(event)
  const { allowed, remaining } = await rateLimit(clientIP, 100, 60000) // 100次/分钟

  if (!allowed) {
    throw createError({
      statusCode: 429,
      statusMessage: '请求过于频繁，请稍后再试',
      headers: {
        'X-RateLimit-Limit': '100',
        'X-RateLimit-Remaining': String(remaining),
        'X-RateLimit-Reset': String(Date.now() + 60000)
      }
    })
  }
})
```

**CORS 配置：**
```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    routeRules: {
      '/api/**': {
        cors: true,
        headers: {
          'Access-Control-Allow-Origin': process.env.ALLOWED_ORIGINS || 'http://localhost:3000',
          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type,Authorization',
          'Access-Control-Max-Age': '86400'
        }
      }
    }
  }
})
```

---

## Performance Considerations

### Database Optimization

**查询优化：**
```typescript
// 索引策略
const indexes = [
  'CREATE INDEX idx_rooms_status ON meeting_rooms(status)',
  'CREATE INDEX idx_reservations_room_time ON reservations(roomId, startTime, endTime)',
  'CREATE INDEX idx_reservations_user ON reservations(userId, startTime)',
  'CREATE INDEX idx_reservations_status ON reservations(status)',
  'CREATE INDEX idx_audit_logs_user_date ON auditLogs(userId, createdAt)'
]

// 查询优化示例
async function getAvailableRooms(startTime: Date, endTime: Date): Promise<MeetingRoom[]> {
  return await prisma.meetingRoom.findMany({
    where: {
      status: 'AVAILABLE',
      reservations: {
        none: {
          AND: [
            { startTime: { lt: endTime } },
            { endTime: { gt: startTime } },
            { status: { not: 'CANCELLED' } }
          ]
        }
      }
    },
    include: {
      _count: {
        select: { reservations: true }
      }
    },
    orderBy: { name: 'asc' }
  })
}
```

**连接池配置：**
```typescript
// Prisma 连接池
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
  log: ['query', 'info', 'warn', 'error'],
  errorFormat: 'pretty',
})

// 连接池配置
const poolConfig = {
  connectionLimit: 20,
  acquireTimeout: 60000,
  timeout: 60000,
  reconnect: true,
  idleTimeout: 30000
}
```

### Caching Strategy

**多层缓存架构：**
```typescript
// 1. 浏览器缓存 (Client-side)
export const browserCache = {
  set: (key: string, data: any, ttl: number) => {
    if (process.client) {
      const item = {
        data,
        expiry: Date.now() + ttl
      }
      localStorage.setItem(key, JSON.stringify(item))
    }
  },

  get: (key: string) => {
    if (process.client) {
      const item = JSON.parse(localStorage.getItem(key) || '{}')
      if (item.expiry > Date.now()) {
        return item.data
      }
      localStorage.removeItem(key)
    }
    return null
  }
}

// 2. 内存缓存 (Server-side)
const memoryCache = new Map<string, { data: any, expiry: number }>()

export const memoryCacheService = {
  set: (key: string, data: any, ttl: number) => {
    memoryCache.set(key, {
      data,
      expiry: Date.now() + ttl
    })
  },

  get: (key: string) => {
    const item = memoryCache.get(key)
    if (item && item.expiry > Date.now()) {
      return item.data
    }
    memoryCache.delete(key)
    return null
  }
}

// 3. Redis 缓存 (Distributed)
export const redisCacheService = {
  set: async (key: string, data: any, ttl: number) => {
    await cacheService.set(key, data, { ttl })
  },

  get: async (key: string) => {
    return await cacheService.get(key)
  }
}
```

**缓存策略：**
```typescript
// 缓存策略配置
const cacheStrategies = {
  // 会议室列表 - 短期缓存
  rooms: {
    ttl: 600, // 10分钟
    strategy: 'write-through'
  },

  // 用户信息 - 中期缓存
  user: {
    ttl: 1800, // 30分钟
    strategy: 'cache-aside'
  },

  // 系统配置 - 长期缓存
  config: {
    ttl: 86400, // 24小时
    strategy: 'read-through'
  },

  // 统计数据 - 中期缓存
  statistics: {
    ttl: 3600, // 1小时
    strategy: 'write-behind'
  }
}
```

### Frontend Performance

**代码分割：**
```typescript
// 路由级代码分割
const routes = [
  {
    path: '/admin',
    component: () => import('~/pages/admin/index.vue')
  },
  {
    path: '/rooms/:id',
    component: () => import('~/pages/rooms/[id].vue')
  }
]

// 组件级代码分割
const AdminPanel = defineAsyncComponent(() =>
  import('~/components/admin/AdminPanel.vue')
)
```

**图片优化：**
```typescript
// 图片压缩和优化
export const imageOptimization = {
  // 压缩设置
  quality: 80,
  maxWidth: 1920,
  maxHeight: 1080,

  // 格式转换
  formats: ['webp', 'avif'],

  // 响应式图片
  sizes: {
    thumbnail: { width: 300, height: 200 },
    medium: { width: 800, height: 600 },
    large: { width: 1200, height: 800 }
  }
}

// 懒加载图片
const LazyImage = defineComponent({
  props: ['src', 'alt'],
  setup(props) {
    const { $image } = useNuxtApp()
    const imageRef = ref(null)

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const img = entry.target as HTMLImageElement
          img.src = props.src
          observer.unobserve(img)
        }
      })
    })

    onMounted(() => {
      if (imageRef.value) {
        observer.observe(imageRef.value)
      }
    })

    return { imageRef }
  }
})
```

---

## Deployment Architecture

### Development Environment

**本地开发配置：**
```bash
# 环境变量配置
NODE_ENV="development"
PORT="3000"
DATABASE_URL="mysql://root:407033@localhost:3307/meeting_manage"
REDIS_URL="redis://localhost:6379"
JWT_SECRET="dev-jwt-secret-key"
UPLOAD_DIR="./public/uploads"
```

**开发工具配置：**
```json
{
  "scripts": {
    "dev": "nuxt dev --port 3000",
    "build": "nuxt build",
    "preview": "nuxt preview",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:studio": "prisma studio",
    "lint": "eslint . --ext .vue,.js,.ts",
    "lint:fix": "eslint . --ext .vue,.js,.ts --fix",
    "type-check": "nuxt typecheck"
  }
}
```

### Production Deployment

**Docker 配置：**
```dockerfile
# Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM node:18-alpine AS runner

WORKDIR /app
COPY --from=builder /app/.output ./.output
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/node_modules ./node_modules

EXPOSE 3000
CMD ["node", ".output/server/index.mjs"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - '3000:3000'
    environment:
      - NODE_ENV=production
      - DATABASE_URL=mysql://root:407033@mysql:3306/meeting_manage
      - REDIS_URL=redis://redis:6379
    depends_on:
      - mysql
      - redis

  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=407033
      - MYSQL_DATABASE=meeting_manage
    ports:
      - '3307:3306'
    volumes:
      - mysql_data:/var/lib/mysql

  redis:
    image: redis:7-alpine
    ports:
      - '6379:6379'
    volumes:
      - redis_data:/data

volumes:
  mysql_data:
  redis_data:
```

**环境配置：**
```bash
# 生产环境变量
NODE_ENV="production"
PORT="3000"
DATABASE_URL="mysql://user:password@mysql:3306/meeting_manage"
REDIS_URL="redis://redis:6379"
JWT_SECRET="production-jwt-secret-key"
UPLOAD_DIR="/app/uploads"
```

### Monitoring & Logging

**健康检查：**
```typescript
// server/api/v1/health.get.ts
export default defineEventHandler(async (event) => {
  const checks = {
    database: await checkDatabaseHealth(),
    redis: await checkRedisHealth(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    timestamp: new Date().toISOString()
  }

  const isHealthy = Object.values(checks).every(check =>
    typeof check === 'boolean' ? check : true
  )

  setResponseStatus(event, isHealthy ? 200 : 503)

  return {
    status: isHealthy ? 'healthy' : 'unhealthy',
    checks
  }
})
```

**性能监控：**
```typescript
// 性能监控中间件
export default defineEventHandler(async (event) => {
  const startTime = Date.now()

  // 执行请求处理
  const response = await handler(event)

  const duration = Date.now() - startTime

  // 记录性能指标
  await recordPerformanceMetrics({
    path: getRequestPath(event),
    method: getRequestMethod(event),
    duration,
    statusCode: getResponseStatus(event),
    timestamp: new Date().toISOString()
  })

  return response
})
```

---

## Development Environment

### Prerequisites

**必需软件：**
- Node.js 18+
- pnpm 8+
- MySQL 8.0+
- Redis 7+ (可选)
- Git

**推荐工具：**
- VS Code + Vue Language Features (Volar)
- MySQL Workbench 或 DBeaver
- Redis Desktop Manager
- Postman 或 Insomnia (API 测试)

### Setup Commands

```bash
# 1. 克隆项目
git clone <repository-url> meeting-manage
cd meeting-manage

# 2. 安装依赖
pnpm install

# 3. 配置环境变量
cp .env.example .env.local
# 编辑 .env.local 配置数据库连接

# 4. 初始化数据库
# 创建数据库
mysql -h localhost -P 3307 -u root -p407033 -e "CREATE DATABASE IF NOT EXISTS meeting_manage;"

# 生成 Prisma 客户端
pnpm db:generate

# 运行数据库迁移
pnpm db:migrate

# 5. 启动开发服务器
pnpm dev

# 6. 访问应用
# 前端: http://localhost:3000
# API: http://localhost:3000/api/v1
# Prisma Studio: pnpm db:studio
```

### Development Workflow

**数据库操作：**
```bash
# 创建新迁移
pnpm prisma migrate dev --name "add_user_table"

# 重置数据库
pnpm prisma migrate reset

# 查看数据库
pnpm prisma studio

# 种子数据
pnpm db:seed
```

**代码质量检查：**
```bash
# ESLint 检查
pnpm lint

# 自动修复
pnpm lint:fix

# TypeScript 类型检查
pnpm type-check

# 格式化代码
pnpm format
```

---

## Architecture Decision Records (ADRs)

### ADR-001: 技术栈选择
**决策：** 采用 Nuxt 4 + PrimeVue + MySQL + Prisma 技术栈
**状态：** 已接受
**理由：**
- Nuxt 4 提供完整的全栈开发体验
- PrimeVue 提供企业级 UI 组件，符合商务需求
- MySQL + Prisma 提供类型安全的数据持久化
- 整个技术栈生态成熟，社区支持良好

### ADR-002: API 设计模式
**决策：** 采用 RESTful API + 统一响应格式
**状态：** 已接受
**理由：**
- RESTful 是行业标准，易于理解和维护
- 统一响应格式提供一致的开发体验
- 支持良好的错误处理和状态码管理

### ADR-003: 状态管理策略
**决策：** 使用 Pinia 作为状态管理库
**状态：** 已接受
**理由：**
- Pinia 是 Vue 3 官方推荐的状态管理库
- 提供简洁的 API 和 TypeScript 支持
- 支持持久化和开发工具集成

### ADR-004: 缓存架构
**决策：** 实现多层缓存架构（浏览器 + 内存 + Redis）
**状态：** 已接受
**理由：**
- 多层缓存提供最佳性能
- Redis 支持分布式部署
- 缓存策略可根据数据特性灵活配置

### ADR-005: 文件存储策略
**决策：** 采用本地文件系统存储
**状态：** 已接受
**理由：**
- 简单可靠，易于部署和维护
- 满足当前系统需求
- 可以后期扩展到云存储

### ADR-006: 安全架构
**决策：** JWT + RBAC 权限模型
**状态：** 已接受
**理由：**
- JWT 提供无状态认证
- RBAC 模型满足企业级权限管理需求
- 支持细粒度权限控制

### ADR-007: 开发工具链
**决策：** TypeScript + ESLint + Prettier
**状态：** 已接受
**理由：**
- TypeScript 提供类型安全
- ESLint 和 Prettier 确保代码质量
- 统一的开发规范和代码风格

---

## Implementation Guidelines

### 开发规范

**代码风格：**
- 使用 TypeScript 严格模式
- 遵循 Vue 3 Composition API 最佳实践
- 组件和函数使用有意义的名称
- 添加适当的注释和文档

**测试策略：**
- 单元测试覆盖核心业务逻辑
- API 测试覆盖所有端点
- 集成测试验证关键用户流程

**部署流程：**
- 使用 Docker 容器化部署
- 实施 CI/CD 自动化流水线
- 配置监控和日志收集

### 扩展规划

**短期扩展（1-3个月）：**
- 完善现有功能模块
- 优化性能和用户体验
- 添加数据分析功能

**中期扩展（3-6个月）：**
- 集成 Hyd 企业 SSO
- 添加 IoT 设备支持
- 实现移动端优化

**长期扩展（6个月+）：**
- 支持多租户架构
- 添加 AI 智能推荐
- 实现微服务架构

---

_Generated by BMAD Decision Architecture Workflow v1.0_
_Date: 2025-11-15_
_For: bmad_
